package edu.southwestern.tasks.mario;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;

import org.apache.commons.lang.ArrayUtils;

import ch.idsia.ai.agents.Agent;
import ch.idsia.mario.engine.level.Level;
import ch.idsia.tools.CmdLineOptions;
import ch.idsia.tools.EvaluationInfo;
import ch.idsia.tools.EvaluationOptions;
import edu.southwestern.MMNEAT.MMNEAT;
import edu.southwestern.evolution.GenerationalEA;
import edu.southwestern.evolution.genotypes.CPPNOrDirectToGANGenotype;
import edu.southwestern.evolution.genotypes.Genotype;
import edu.southwestern.evolution.mapelites.Archive;
import edu.southwestern.evolution.mapelites.MAPElites;
import edu.southwestern.evolution.mapelites.generalmappings.KLDivergenceBinLabels;
import edu.southwestern.parameters.CommonConstants;
import edu.southwestern.parameters.Parameters;
import edu.southwestern.scores.Score;
import edu.southwestern.tasks.NoisyLonerTask;
import edu.southwestern.tasks.mario.level.LevelParser;
import edu.southwestern.tasks.mario.level.MarioLevelUtil;
import edu.southwestern.tasks.mario.level.MarioState;
import edu.southwestern.tasks.mario.level.MarioState.MarioAction;
import edu.southwestern.tasks.mario.level.OldLevelParser;
import edu.southwestern.util.ClassCreation;
import edu.southwestern.util.datastructures.ArrayUtil;
import edu.southwestern.util.datastructures.Pair;
import edu.southwestern.util.file.FileUtilities;
import edu.southwestern.util.graphics.GraphicsUtil;
import edu.southwestern.util.random.RandomNumbers;
import edu.southwestern.util.search.AStarSearch;
import edu.southwestern.util.search.Search;


/**
 * 
 * Evolve Mario levels using an agent,
 * like the Mario A* Agent, as a means of evaluating.
 * Levels can be generated by CPPNs or a GAN, but this is
 * done in child classes.
 * 
 * @author Jacob Schrum
 *
 * @param <T>
 */
public abstract class MarioLevelTask<T> extends NoisyLonerTask<T> {	

	private static final int SEGMENT_WIDTH_IN_BLOCKS = 28; // GAN training window
	private static final int PIXEL_BLOCK_WIDTH = 16; // Is this right?

	private Agent agent;
	private int numFitnessFunctions;
	private boolean fitnessRequiresSimulation;
	private boolean segmentFitness;
	private ArrayList<List<Integer>> targetLevel = null;
	private int[][][] klDivLevels;
	
	private boolean initialized = false; // become true on first evaluation

	public static final int DECORATION_FREQUENCY_STAT_INDEX = 0;
	public static final int LENIENCY_STAT_INDEX = 1;
	public static final int NEGATIVE_SPACE_STAT_INDEX = 2;
	public static final int NUM_SEGMENT_STATS = 3;

	// Calculated in oneEval, so it can be passed on the getBehaviorVector
	private ArrayList<Double> behaviorVector;
	private Pair<int[],Double> oneMAPEliteBinIndexScorePair;
	
	public MarioLevelTask() {
		// Replace this with a command line parameter
		try {
			agent = (Agent) ClassCreation.createObject("marioLevelAgent");
		} catch (NoSuchMethodException e) {
			e.printStackTrace();
			System.out.println("Could not instantiate Mario agent");
			System.exit(1);
		}

		// Fitness
		numFitnessFunctions = 0;
		fitnessRequiresSimulation = false; // Until proven otherwise
		segmentFitness = false;
		if(Parameters.parameters.booleanParameter("marioProgressPlusJumpsFitness")) {
			// First maximize progress through the level.
			// If the level is cleared, then maximize the duration of the
			// level, which will indicate that it is challenging.
			MMNEAT.registerFitnessFunction("ProgressPlusJumps");
			fitnessRequiresSimulation = true;
			numFitnessFunctions++;
		} 
		if(Parameters.parameters.booleanParameter("marioProgressPlusTimeFitness")) {
			// Levels that take longer must be harder
			MMNEAT.registerFitnessFunction("ProgressPlusTime");
			fitnessRequiresSimulation = true;
			numFitnessFunctions++;
		}
		if(Parameters.parameters.booleanParameter("marioLevelMatchFitness")) {
			MMNEAT.registerFitnessFunction("LevelMatch");
			numFitnessFunctions++;
			// Load level representation from file here
			String levelFileName = Parameters.parameters.stringParameter("marioTargetLevel"); // Does not have a default value yet
			targetLevel = MarioLevelUtil.listLevelFromVGLCFile(levelFileName);

			// View whole dungeon layout
			Level level = Parameters.parameters.booleanParameter("marioGANUsesOriginalEncoding") ? OldLevelParser.createLevelJson(targetLevel) : LevelParser.createLevelJson(targetLevel);			
			BufferedImage image = MarioLevelUtil.getLevelImage(level);
			String saveDir = FileUtilities.getSaveDirectory();
			GraphicsUtil.saveImage(image, saveDir + File.separator + "Target.png");

		}
		// Encourages an alternating pattern of Vanessa's objectives
		if(Parameters.parameters.booleanParameter("marioLevelAlternatingLeniency")) {
			MMNEAT.registerFitnessFunction("AlternatingLeniency");
			segmentFitness = true;
			numFitnessFunctions++;
		}
		if(Parameters.parameters.booleanParameter("marioLevelAlternatingNegativeSpace")) {
			MMNEAT.registerFitnessFunction("AlternatingNegativeSpace");
			segmentFitness = true;
			numFitnessFunctions++;			
		}
		if(Parameters.parameters.booleanParameter("marioLevelAlternatingDecoration")) {
			MMNEAT.registerFitnessFunction("AlternatingDecorationFrequency");
			segmentFitness = true;
			numFitnessFunctions++;
		}
		// Encourages an periodic pattern of Vanessa's objectives
		if(Parameters.parameters.booleanParameter("marioLevelPeriodicLeniency")) {
			MMNEAT.registerFitnessFunction("PeriodicLeniency");
			segmentFitness = true;
			numFitnessFunctions++;
		}
		if(Parameters.parameters.booleanParameter("marioLevelPeriodicNegativeSpace")) {
			MMNEAT.registerFitnessFunction("PeriodicNegativeSpace");
			segmentFitness = true;
			numFitnessFunctions++;			
		}
		if(Parameters.parameters.booleanParameter("marioLevelPeriodicDecoration")) {
			MMNEAT.registerFitnessFunction("PeriodicDecorationFrequency");
			segmentFitness = true;
			numFitnessFunctions++;
		}

		// Encourages a symmetric pattern of Vanessa's objectives
		if(Parameters.parameters.booleanParameter("marioLevelSymmetricLeniency")) {
			MMNEAT.registerFitnessFunction("SymmetricLeniency");
			segmentFitness = true;
			numFitnessFunctions++;			
		}
		if(Parameters.parameters.booleanParameter("marioLevelSymmetricNegativeSpace")) {
			MMNEAT.registerFitnessFunction("SymmetricNegativeSpace");
			segmentFitness = true;
			numFitnessFunctions++;						
		}
		if(Parameters.parameters.booleanParameter("marioLevelSymmetricDecoration")) {
			MMNEAT.registerFitnessFunction("SymmetricDecorationFrequency");
			segmentFitness = true;
			numFitnessFunctions++;			
		}

		if(Parameters.parameters.booleanParameter("marioSimpleAStarDistance")) {
			MMNEAT.registerFitnessFunction("SimpleA*Distance");
			numFitnessFunctions++;			
		}

		if(Parameters.parameters.booleanParameter("marioRandomFitness")) {
			MMNEAT.registerFitnessFunction("Random");
			numFitnessFunctions++;
		}
		if(Parameters.parameters.booleanParameter("marioDistinctSegmentFitness")) {
			MMNEAT.registerFitnessFunction("Random");
			numFitnessFunctions++;
		}
		if(numFitnessFunctions == 0) throw new IllegalStateException("At least one fitness function required to evolve Mario levels");
		// Other scores
		MMNEAT.registerFitnessFunction("Distance", false);
		MMNEAT.registerFitnessFunction("PercentDistance", false);
		MMNEAT.registerFitnessFunction("Time", false);
		MMNEAT.registerFitnessFunction("Jumps", false);
		for(int i=0; i<Parameters.parameters.integerParameter("marioGANLevelChunks"); i++){
			MMNEAT.registerFitnessFunction("DecorationFrequency-"+i,false);
			MMNEAT.registerFitnessFunction("Leniency-"+i,false);
			MMNEAT.registerFitnessFunction("NegativeSpace-"+i,false);
		}
		setupKLDivLevelsForComparison();
	}

	@SuppressWarnings("unchecked")
	private void setupKLDivLevelsForComparison() {
		if (MMNEAT.ea instanceof MAPElites && ((MAPElites<T>) MMNEAT.ea).getBinLabelsClass() instanceof KLDivergenceBinLabels) { // TODO
			System.out.println("Instance of MAP Elites using KL Divergence Bin Labels");
			String level1FileName = Parameters.parameters.stringParameter("mapElitesKLDivLevel1"); 
			String level2FileName = Parameters.parameters.stringParameter("mapElitesKLDivLevel2"); 
			ArrayList<List<Integer>> level1List = MarioLevelUtil.listLevelFromVGLCFile(level1FileName);
			ArrayList<List<Integer>> level2List = MarioLevelUtil.listLevelFromVGLCFile(level2FileName);
			int[][] level1Array = ArrayUtil.int2DArrayFromListOfLists(level1List);
			int[][] level2Array = ArrayUtil.int2DArrayFromListOfLists(level2List);
			klDivLevels = new int[][][] {level1Array, level2Array};
		}
	}

	@Override
	public int numObjectives() {
		return numFitnessFunctions;  
	}

	public int numOtherScores() {
		return 4 + Parameters.parameters.integerParameter("marioGANLevelChunks") * 3; // Distance, Percentage, Time, and Jumps 
		//plus (decorationFrequency, leniency, negativeSpace) per level segment
	}

	@Override
	public double getTimeStamp() {
		return 0; // Not used
	}

	/**
	 * Different level generators use the genotype to generate a level in different ways
	 * @param individual Genotype 
	 * @return List of lists of integers corresponding to tile types
	 */
	public abstract ArrayList<List<Integer>> getMarioLevelListRepresentationFromGenotype(Genotype<T> individual);

	/**
	 * Different level generators generate levels of different lengths
	 * @param info 
	 * @return
	 */
	public abstract double totalPassableDistance(EvaluationInfo info);

	
	@Override
	public Score<T> evaluate(Genotype<T> individual) {
		Score<T> result = super.evaluate(individual);
		if(MMNEAT.ea instanceof MAPElites)
			result.assignMAPElitesBinAndScore(oneMAPEliteBinIndexScorePair.t1, oneMAPEliteBinIndexScorePair.t2);
		return result;
	}
	
	
	@SuppressWarnings("unchecked")
	@Override
	public Pair<double[], double[]> oneEval(Genotype<T> individual, int num) {
		if(!initialized) setupKLDivLevelsForComparison();
		initialized = true;
		EvaluationInfo info = null;
		BufferedImage levelImage = null;
		ArrayList<List<Integer>> oneLevel = getMarioLevelListRepresentationFromGenotype(individual);
		Level level = Parameters.parameters.booleanParameter("marioGANUsesOriginalEncoding") ? OldLevelParser.createLevelJson(oneLevel) : LevelParser.createLevelJson(oneLevel);			
		if(fitnessRequiresSimulation || CommonConstants.watch) {
			agent.reset(); // Get ready to play a new level
			EvaluationOptions options = new CmdLineOptions(new String[]{});
			options.setAgent(agent);
			options.setLevel(level);
			options.setMaxFPS(!(agent instanceof ch.idsia.ai.agents.human.HumanKeyboardAgent)); // Run fast when not playing
			options.setVisualization(CommonConstants.watch);

			List<EvaluationInfo> infos = MarioLevelUtil.agentPlaysLevel(options);
			// For now, assume a single evaluation
			info = infos.get(0);
		}
		
		if(MMNEAT.ea instanceof MAPElites || CommonConstants.watch) {
			// View whole dungeon layout
			levelImage = MarioLevelUtil.getLevelImage(level);
			if(segmentFitness) { // Draw lines dividing the segments 
				Graphics2D g = (Graphics2D) levelImage.getGraphics();
				g.setColor(Color.MAGENTA);
				g.setStroke(new BasicStroke(4)); // Thicker line
				for(int i = 1; i < Parameters.parameters.integerParameter("marioGANLevelChunks"); i++) {
					g.drawLine(i*PIXEL_BLOCK_WIDTH*SEGMENT_WIDTH_IN_BLOCKS, 0, i*PIXEL_BLOCK_WIDTH*SEGMENT_WIDTH_IN_BLOCKS, levelImage.getHeight());
				}
			}
			
			// MAP Elites images get saved later, in a different directory
			if(!(MMNEAT.ea instanceof MAPElites)) {
				String saveDir = FileUtilities.getSaveDirectory();
				int currentGen = ((GenerationalEA) MMNEAT.ea).currentGeneration();
				GraphicsUtil.saveImage(levelImage, saveDir + File.separator + (currentGen == 0 ? "initial" : "gen"+ currentGen) + File.separator + "MarioLevel"+individual.getId()+".png");
			}
		}


		double distancePassed = info == null ? 0 : info.lengthOfLevelPassedPhys;
		double percentLevelPassed = info == null ? 0 : distancePassed / totalPassableDistance(info);
		double time = info == null ? 0 : info.timeSpentOnLevel;
		double jumps = info == null ? 0 : info.jumpActionsPerformed;
		int numDistinctSegments;
		//put each segment into a HashSet to see if it's  distinct
		HashSet<ArrayList<List<Integer>>> k = new HashSet<ArrayList<List<Integer>>>();
        ArrayList<ArrayList<List<Integer>>> levelWithParsedSegments = MarioLevelUtil.getSegmentsFromLevel(oneLevel, SEGMENT_WIDTH_IN_BLOCKS);
        //int numSegments = 0;
        for(ArrayList<List<Integer>> segment : levelWithParsedSegments) {
        	k.add(segment);
        	//numSegments++;
        }
//		int numSegments = levelWithParsedSegments.size();
		numDistinctSegments = k.size();

		
		
		double[] otherScores = new double[] {distancePassed, percentLevelPassed, time, jumps};
		// Adds Vanessa's Mario stats: Decoration Frequency, Leniency, Negative Space
		ArrayList<double[]> lastLevelStats = LevelParser.getLevelStats(oneLevel, SEGMENT_WIDTH_IN_BLOCKS);
		for(double[] stats:lastLevelStats){
			otherScores = ArrayUtils.addAll(otherScores, stats);
		}

		ArrayList<Double> fitnesses = new ArrayList<>(numFitnessFunctions);
		if(Parameters.parameters.booleanParameter("marioProgressPlusJumpsFitness")) {
			if(percentLevelPassed < 1.0) {
				fitnesses.add(percentLevelPassed);
			} else { // Level beaten
				fitnesses.add(1.0+jumps);
			}
		} 
		if(Parameters.parameters.booleanParameter("marioProgressPlusTimeFitness")) {
			if(percentLevelPassed < 1.0) {
				fitnesses.add(percentLevelPassed);
			} else { // Level beaten
				fitnesses.add(1.0+time);
			}
		}
		if(Parameters.parameters.booleanParameter("marioLevelMatchFitness")) {
			int diffCount = 0;

			if(oneLevel.size() != targetLevel.size()) {
				System.out.println("Target");
				System.out.println(targetLevel);
				System.out.println("Evolved");
				System.out.println(oneLevel);
				throw new IllegalStateException("Target level and evolved level are not even the same height.");
			}

			// This will hold the target level, except that every location of conflict with the evolved level will
			// be replaced with the blank passable background tile
			ArrayList<List<Integer>> targetDiff = new ArrayList<>();

			// TODO
			// Should this calculation include or eliminate the starting and ending regions we add to Mario levels?
			Iterator<List<Integer>> evolveIterator = oneLevel.iterator();
			Iterator<List<Integer>> targetIterator = targetLevel.iterator();
			while(evolveIterator.hasNext() && targetIterator.hasNext()) {
				Iterator<Integer> evolveRow = evolveIterator.next().iterator();
				Iterator<Integer> targetRow = targetIterator.next().iterator();
				List<Integer> diffRow = new ArrayList<>(targetLevel.get(0).size()); // For visualizing differences
				while(evolveRow.hasNext() && targetRow.hasNext()) {
					Integer nextInTarget = targetRow.next();
					if(!evolveRow.next().equals(nextInTarget)) {
						diffCount++;
						diffRow.add(-100); // An illegal tile. Indicates a conflict
					} else {
						diffRow.add(nextInTarget);
					}
				}
				targetDiff.add(diffRow);
			}
			// More differences = worse fitness
			fitnesses.add(-1.0*diffCount);

			if(CommonConstants.watch) {
				// View whole level layout
				Level diffLevel = Parameters.parameters.booleanParameter("marioGANUsesOriginalEncoding") ? OldLevelParser.createLevelJson(targetDiff) : LevelParser.createLevelJson(targetDiff);			
				BufferedImage image = MarioLevelUtil.getLevelImage(diffLevel);
				String saveDir = FileUtilities.getSaveDirectory();
				int currentGen = ((GenerationalEA) MMNEAT.ea).currentGeneration();
				GraphicsUtil.saveImage(image, saveDir + File.separator + (currentGen == 0 ? "initial" : "gen"+ currentGen) + File.separator + "MarioLevel"+individual.getId()+"TargetDiff.png");
			}
		}

		// Encourages an alternating pattern of Vanessa's objectives
		if(Parameters.parameters.booleanParameter("marioLevelAlternatingLeniency")) {
			fitnesses.add(alternatingStatScore(lastLevelStats, LENIENCY_STAT_INDEX));
		}
		if(Parameters.parameters.booleanParameter("marioLevelAlternatingNegativeSpace")) {
			fitnesses.add(alternatingStatScore(lastLevelStats, NEGATIVE_SPACE_STAT_INDEX));
		}
		if(Parameters.parameters.booleanParameter("marioLevelAlternatingDecoration")) {
			fitnesses.add(alternatingStatScore(lastLevelStats, DECORATION_FREQUENCY_STAT_INDEX));
		}

		// Encourages a periodic pattern of Vanessa's objectives
		if(Parameters.parameters.booleanParameter("marioLevelPeriodicLeniency")) {
			fitnesses.add(periodicStatScore(lastLevelStats, LENIENCY_STAT_INDEX));
		}
		if(Parameters.parameters.booleanParameter("marioLevelPeriodicNegativeSpace")) {
			fitnesses.add(periodicStatScore(lastLevelStats, NEGATIVE_SPACE_STAT_INDEX));
		}
		if(Parameters.parameters.booleanParameter("marioLevelPeriodicDecoration")) {
			fitnesses.add(periodicStatScore(lastLevelStats, DECORATION_FREQUENCY_STAT_INDEX));
		}

		// Encourages a symmetric pattern of Vanessa's objectives
		if(Parameters.parameters.booleanParameter("marioLevelSymmetricLeniency")) {
			fitnesses.add(symmetricStatScore(lastLevelStats, LENIENCY_STAT_INDEX));
		}
		if(Parameters.parameters.booleanParameter("marioLevelSymmetricNegativeSpace")) {
			fitnesses.add(symmetricStatScore(lastLevelStats, NEGATIVE_SPACE_STAT_INDEX));
		}
		if(Parameters.parameters.booleanParameter("marioLevelSymmetricDecoration")) {
			fitnesses.add(symmetricStatScore(lastLevelStats, DECORATION_FREQUENCY_STAT_INDEX));
		}

		double simpleAStarDistance = -1;
		if(Parameters.parameters.booleanParameter("marioSimpleAStarDistance")) {
			MarioState start = new MarioState(MarioState.preprocessLevel(oneLevel));
			Search<MarioAction,MarioState> search = new AStarSearch<>(MarioState.moveRight);
			HashSet<MarioState> mostRecentVisited = null;
			ArrayList<MarioAction> actionSequence = null;
			try{
				actionSequence = ((AStarSearch<MarioAction, MarioState>) search).search(start, true, Parameters.parameters.integerParameter("aStarSearchBudget"));
				if(actionSequence == null) {
					fitnesses.add(-1.0); // failed search 				
				} else {
					simpleAStarDistance = 1.0*actionSequence.size(); // For MAP Elites bin later
					fitnesses.add(1.0*actionSequence.size()); // maximize length of solution
				}
			} catch(IllegalStateException e) {
				// Sometimes this exception occurs from A*. Not sure why, but we can take this to mean the level has a problem and deserves bad fitness.
				fitnesses.add(-1.0); // failed search 				
			} finally {
				mostRecentVisited = ((AStarSearch<MarioAction, MarioState>) search).getVisited();
			}

			if(MMNEAT.ea instanceof MAPElites || (CommonConstants.netio && CommonConstants.watch)) {
				// Add X marks to the original level image, which should exist if since watch saved it above
				if(mostRecentVisited != null) {
					Graphics2D g = (Graphics2D) levelImage.getGraphics();
					g.setColor(Color.BLUE);
					g.setStroke(new BasicStroke(4)); // Thicker line
					for(MarioState s : mostRecentVisited) {
						int x = s.marioX - LevelParser.BUFFER_WIDTH;
						int y = s.marioY;
						g.drawLine(x*PIXEL_BLOCK_WIDTH, y*PIXEL_BLOCK_WIDTH, (x+1)*PIXEL_BLOCK_WIDTH, (y+1)*PIXEL_BLOCK_WIDTH);
						g.drawLine((x+1)*PIXEL_BLOCK_WIDTH, y*PIXEL_BLOCK_WIDTH, x*PIXEL_BLOCK_WIDTH, (y+1)*PIXEL_BLOCK_WIDTH);
					}
					
					if(actionSequence != null) {
						MarioState current = start;
						g.setColor(Color.RED);
						for(MarioAction a : actionSequence) {
							int x = current.marioX - LevelParser.BUFFER_WIDTH;
							int y = current.marioY;
							g.drawLine(x*PIXEL_BLOCK_WIDTH, y*PIXEL_BLOCK_WIDTH, (x+1)*PIXEL_BLOCK_WIDTH, (y+1)*PIXEL_BLOCK_WIDTH);
							g.drawLine((x+1)*PIXEL_BLOCK_WIDTH, y*PIXEL_BLOCK_WIDTH, x*PIXEL_BLOCK_WIDTH, (y+1)*PIXEL_BLOCK_WIDTH);
							current = (MarioState) current.getSuccessor(a);
						}
					}
				}

				if(!(MMNEAT.ea instanceof MAPElites)) {
					// View level with path
					String saveDir = FileUtilities.getSaveDirectory();
					int currentGen = ((GenerationalEA) MMNEAT.ea).currentGeneration();
					GraphicsUtil.saveImage(levelImage, saveDir + File.separator + (currentGen == 0 ? "initial" : "gen"+ currentGen) + File.separator + "MarioLevel"+individual.getId()+"SolutionPath.png");
				}
			}
		}

		if(Parameters.parameters.booleanParameter("marioRandomFitness")) {
			fitnesses.add(RandomNumbers.fullSmallRand());
		}
		if(Parameters.parameters.booleanParameter("marioDistinctSegmentFitness")) {
			fitnesses.add(new Double(numDistinctSegments));
		}
		// Could conceivably also be used for behavioral diversity instead of map elites, but this would be a weird behavior vector from a BD perspective
		if(MMNEAT.ea instanceof MAPElites) {
			// Assign to the behavior vector before using MAP-Elites
			//double[] archiveArray;
			//int binIndex;
			int[] dims;
			double leniencySum = sumStatScore(lastLevelStats, LENIENCY_STAT_INDEX);
			double DECORATION_SCALE = 3;
			double NEGATIVE_SPACE_SCALE = 3;
			// Scale scores so that we are less likely to overstep the bounds of the bins
			final int BINS_PER_DIMENSION = Parameters.parameters.integerParameter("marioGANLevelChunks");
			double decorationSum = sumStatScore(lastLevelStats, DECORATION_FREQUENCY_STAT_INDEX);
			double negativeSpaceSum = sumStatScore(lastLevelStats, NEGATIVE_SPACE_STAT_INDEX);
			int leniencySumIndex = Math.min(Math.max((int)((leniencySum*(BINS_PER_DIMENSION/2)+0.5)*BINS_PER_DIMENSION),0), BINS_PER_DIMENSION-1); //LEANIENCY BIN INDEX
			int decorationBinIndex =  Math.min((int)(decorationSum*DECORATION_SCALE*BINS_PER_DIMENSION), BINS_PER_DIMENSION-1); //decorationBinIndex
			int negativeSpaceSumIndex = Math.min((int)(negativeSpaceSum*NEGATIVE_SPACE_SCALE*BINS_PER_DIMENSION), BINS_PER_DIMENSION-1); //negative space index
			assert Parameters.parameters.booleanParameter("marioSimpleAStarDistance") : "Bin score will be -1 everywhere if you don't calculate the A* distance. Set marioSimpleAStarDistance:true";
			double binScore = simpleAStarDistance;
			

			if(((MAPElites<T>) MMNEAT.ea).getBinLabelsClass() instanceof MarioMAPElitesDecorNSAndLeniencyBinLabels) {
				dims = new int[] {decorationBinIndex, negativeSpaceSumIndex, leniencySumIndex};

//				archiveArray = new double[BINS_PER_DIMENSION*BINS_PER_DIMENSION*BINS_PER_DIMENSION];
			}else if(((MAPElites<T>) MMNEAT.ea).getBinLabelsClass() instanceof MarioMAPElitesDistinctChunksNSAndLeniencyBinLabels) {
				//double decorationSum = sumStatScore(lastLevelStats, DECORATION_FREQUENCY_STAT_INDEX);
				dims = new int[] {numDistinctSegments, negativeSpaceSumIndex, leniencySumIndex};
				// Row-major order lookup in 3D archive
				
//				archiveArray = new double[(BINS_PER_DIMENSION+1)*BINS_PER_DIMENSION*BINS_PER_DIMENSION];
			}else if(((MAPElites<T>) MMNEAT.ea).getBinLabelsClass() instanceof MarioMAPElitesDistinctChunksNSAndDecorationBinLabels) {
				assert Parameters.parameters.integerParameter("marioGANLevelChunks") > 1 : "Can't have variation with MarioMAPElitesDistinctChunksNSAndDecorationBinLabels bin scheme if marioGANLevelChunks:1 is set!";
				double decorationAlternating = alternatingStatScore(lastLevelStats, DECORATION_FREQUENCY_STAT_INDEX);
				double negativeSpaceAlternating = alternatingStatScore(lastLevelStats, NEGATIVE_SPACE_STAT_INDEX);
				
				// Lower the scale when using alternating score
				DECORATION_SCALE = 0.2;
				NEGATIVE_SPACE_SCALE = 0.85;
				
				decorationBinIndex = Math.min((int)(decorationAlternating*DECORATION_SCALE*BINS_PER_DIMENSION*10), BINS_PER_DIMENSION-1);
				negativeSpaceSumIndex = Math.min((int)(negativeSpaceAlternating*NEGATIVE_SPACE_SCALE*BINS_PER_DIMENSION), BINS_PER_DIMENSION-1);
				
				// Do not assert: we allow the range to be broken sometimes
				//assert (decorationAlternating*DECORATION_SCALE*BINS_PER_DIMENSION*10) <= BINS_PER_DIMENSION : "Decorate too big: " +(BINS_PER_DIMENSION)+" < " + (decorationAlternating*DECORATION_SCALE*BINS_PER_DIMENSION*10);
				//assert (negativeSpaceAlternating*NEGATIVE_SPACE_SCALE*BINS_PER_DIMENSION) <= BINS_PER_DIMENSION-1 : "NS too big: " +(BINS_PER_DIMENSION-1)+" < " + (negativeSpaceAlternating*NEGATIVE_SPACE_SCALE*BINS_PER_DIMENSION);
				
				dims = new int[] {numDistinctSegments, negativeSpaceSumIndex, decorationBinIndex};
				
//				archiveArray = new double[(BINS_PER_DIMENSION+1)*BINS_PER_DIMENSION*BINS_PER_DIMENSION];				
			} else if (((MAPElites<T>) MMNEAT.ea).getBinLabelsClass() instanceof KLDivergenceBinLabels) { // TODO
				KLDivergenceBinLabels klLabels = (KLDivergenceBinLabels) ((MAPElites<T>) MMNEAT.ea).getBinLabelsClass();
				
				int[][] oneLevelAs2DArray = ArrayUtil.int2DArrayFromListOfLists(oneLevel);
				dims = klLabels.discretize(KLDivergenceBinLabels.behaviorCharacterization(oneLevelAs2DArray, klDivLevels));
				
			} else {
				throw new RuntimeException("A Valid Binning Scheme For Mario Was Not Specified");
			}
			// Row-major order lookup in 3D archive
			//setBinsAndSaveMAPElitesImages(individual, levelImage, archiveArray, dim1, dim2, dim3, BINS_PER_DIMENSION, binScore);
			setBinsAndSaveMAPElitesImages(individual, levelImage, dims, binScore);

		}
		return new Pair<double[],double[]>(ArrayUtil.doubleArrayFromList(fitnesses), otherScores);
		
	}

	/**
	 * sets the bins and saves MAPElites images to archive
	 * @param individual the genotype
	 * @param levelImage the buffered image of the level
	 * @param dims Array of dimensions corresponding to each bin
	 * @param binScore the bin score
	 */
	private void setBinsAndSaveMAPElitesImages(Genotype<T> individual, BufferedImage levelImage,
			int[] dims, double binScore) {
		
		oneMAPEliteBinIndexScorePair = new Pair<int[], Double>(dims, binScore);
		
//		int binIndex = (dim1*BINS_PER_DIMENSION + dim2)*BINS_PER_DIMENSION + dim3;
//		Arrays.fill(archiveArray, Double.NEGATIVE_INFINITY); // Worst score in all dimensions
//		archiveArray[binIndex] = binScore; // Percent rooms traversed
		
		String binScoreString = "";
		for (int dim : dims) {
			binScoreString += ("["+dim+"]");
		}
		System.out.println(binScoreString + " = "+binScore);

//		behaviorVector = ArrayUtil.doubleVectorFromArray(archiveArray);

		// Saving map elites bin images	
		if(CommonConstants.netio) {
			System.out.println("Save archive images");
			@SuppressWarnings("unchecked")
			Archive<T> archive = ((MAPElites<T>) MMNEAT.ea).getArchive();
			List<String> binLabels = archive.getBinMapping().binLabels();

			// Index in flattened bin array
			Score<T> elite = archive.getElite(oneMAPEliteBinIndexScorePair.t1);
			// If the bin is empty, or the candidate is better than the elite for that bin's score
			if(elite == null || binScore > elite.behaviorIndexScore()) {
				String fileName = String.format("%7.5f", binScore) + "_" + individual.getId() + ".png";
				if(individual instanceof CPPNOrDirectToGANGenotype) {
					CPPNOrDirectToGANGenotype temp = (CPPNOrDirectToGANGenotype) individual;
					if(temp.getFirstForm()) fileName = "CPPN-" + fileName;
					else fileName = "Direct-" + fileName;
				}
				String binPath = archive.getArchiveDirectory() + File.separator + binLabels.get(archive.getBinMapping().oneDimensionalIndex(oneMAPEliteBinIndexScorePair.t1));
				String fullName = binPath + "_" + fileName;
				System.out.println(fullName);
				GraphicsUtil.saveImage(levelImage, fullName);
			}
		}
	}

	private double sumStatScore(ArrayList<double[]> levelStats, int statIndex) {
		double total = 0;
		for(int i = 0; i < levelStats.size(); i++) {
			total += levelStats.get(i)[statIndex];
		}
		return total;
	}

	private double periodicStatScore(ArrayList<double[]> levelStats, int statIndex) {
		double evenTotal = 0;
		// even differences
		for(int i = 2; i < levelStats.size(); i += 2) {
			// Differences between even segments
			evenTotal += Math.abs(levelStats.get(i-2)[statIndex] - levelStats.get(i)[statIndex]);
		}
		double oddTotal = 0;
		// odd differences
		for(int i = 3; i < levelStats.size(); i += 2) {
			// Differences between odd segments
			oddTotal += Math.abs(levelStats.get(i-2)[statIndex] - levelStats.get(i)[statIndex]);
		}
		// Negative because differences are discouraged
		return - (evenTotal + oddTotal);
	}

	private double symmetricStatScore(ArrayList<double[]> levelStats, int statIndex) {
		double total = 0;
		for(int i = 0; i < levelStats.size()/2; i++) {
			// Diff between symmetric segments
			total += Math.abs(levelStats.get(i)[statIndex] - levelStats.get(levelStats.size()-1-i)[statIndex]);
		}
		return - total; // Negative: Max symmetry means minimal difference in symmetric segments
	}

	private double alternatingStatScore(ArrayList<double[]> levelStats, int statIndex) {
		double total = 0;
		for(int i = 1; i < levelStats.size(); i++) {
			// Differences between adjacent segments
			total += Math.abs(levelStats.get(i-1)[statIndex] - levelStats.get(i)[statIndex]);
		}
		return total;
	}

	// It is assumed that the data needed to fill this is computed in oneEval, saved globally, and then returned here.
	// This is primarily meant to be used with MAP Elites, so it is an unusual behavior vector. It is really a vector of bins, where
	// the agent's score in each bin is set ... but a given Mario level should really only be in one of the bins.
	public ArrayList<Double> getBehaviorVector() {
		return behaviorVector;
	}
	
	public static void main(String[] args) throws FileNotFoundException, NoSuchMethodException {
		int runNum = 31;
		//MMNEAT.main(("runNumber:"+runNum+" randomSeed:"+runNum+" base:mariolevelskldiv log:MarioLevelsKLDiv-test saveTo:test marioGANLevelChunks:5 marioGANUsesOriginalEncoding:false marioGANModel:Mario1_Overworld_5_Epoch5000.pth GANInputSize:5 trials:1 lambda:50 mu:50 maxGens:5000 io:true netio:true genotype:edu.southwestern.evolution.genotypes.BoundedRealValuedGenotype mating:true fs:false task:edu.southwestern.tasks.mario.MarioGANLevelTask cleanFrequency:-1 saveAllChampions:true cleanOldNetworks:false logTWEANNData:false logMutationAndLineage:false marioStuckTimeout:20 watch:false marioProgressPlusJumpsFitness:false marioRandomFitness:false marioSimpleAStarDistance:true ea:edu.southwestern.evolution.mapelites.MAPElites experiment:edu.southwestern.experiment.evolution.SteadyStateExperiment mapElitesBinLabels:edu.southwestern.evolution.mapelites.generalmappings.KLDivergenceBinLabels steadyStateIndividualsPerGeneration:100 aStarSearchBudget:100000 mapElitesKLDivLevel1:data\\VGLC\\SuperMarioBrosNewEncoding\\overworld\\mario-8-1.txt mapElitesKLDivLevel2:data\\VGLC\\SuperMarioBrosNewEncoding\\overworld\\mario-3-1.txt klDivBinDimension:100 klDivMaxValue:0.3").split(" "));
		MMNEAT.main(("runNumber:"+runNum+" randomSeed:"+runNum+" base:mariolevelskldiv log:MarioLevelsKLDiv-testCMAME saveTo:testCMAME marioGANLevelChunks:5 marioGANUsesOriginalEncoding:false marioGANModel:Mario1_Overworld_5_Epoch5000.pth GANInputSize:5 trials:1 lambda:50 mu:10 maxGens:5000 io:true netio:true genotype:edu.southwestern.evolution.genotypes.BoundedRealValuedGenotype mating:true fs:false task:edu.southwestern.tasks.mario.MarioGANLevelTask cleanFrequency:-1 saveAllChampions:true cleanOldNetworks:false logTWEANNData:false logMutationAndLineage:false marioStuckTimeout:20 watch:false marioProgressPlusJumpsFitness:false marioRandomFitness:false marioSimpleAStarDistance:true ea:edu.southwestern.evolution.mapelites.CMAME experiment:edu.southwestern.experiment.evolution.SteadyStateExperiment mapElitesBinLabels:edu.southwestern.evolution.mapelites.generalmappings.KLDivergenceBinLabels steadyStateIndividualsPerGeneration:100 aStarSearchBudget:100000 mapElitesKLDivLevel1:data\\VGLC\\SuperMarioBrosNewEncoding\\overworld\\mario-8-1.txt mapElitesKLDivLevel2:data\\VGLC\\SuperMarioBrosNewEncoding\\overworld\\mario-3-1.txt klDivBinDimension:100 klDivMaxValue:0.3 numImprovementEmitters:3 numOptimizingEmitters:0").split(" "));
		
	}

}
